\
#include "GestureAirDrawPro.h"\n#include <math.h>\n\n#define RAD_TO_DEG 57.29577951308232f\n\nGestureAirDrawPro::GestureAirDrawPro(){\n  _wire = &Wire;\n  _addr = 0x68;\n  _alpha = 0.98f;\n  _sampleMs = 20;\n  _lastMs = 0;\n  _pitch = _roll = 0.0f;\n  _count = 0;\n  _recording = false;\n  _hasResult = false;\n  _buttonPin = 2;\n  _resultLabel[0]=0;\n}\n\nbool GestureAirDrawPro::begin(uint8_t i2c_addr, uint8_t buttonPin){\n  _addr = i2c_addr;\n  _buttonPin = buttonPin;\n  _wire->begin();\n  // wake MPU6050\n  _wire->beginTransmission(_addr);\n  _wire->write(0x6B);\n  _wire->write(0x00);\n  _wire->endTransmission();\n  pinMode(_buttonPin, INPUT_PULLUP);\n  calibrate();\n  return true;\n}\n\nvoid GestureAirDrawPro::calibrate(){\n  float ax,ay,az,gx,gy,gz;\n  readRawAccelGyro(ax,ay,az,gx,gy,gz);\n  _pitch = atan2f(ay, sqrtf(ax*ax + az*az)) * RAD_TO_DEG;\n  _roll  = atan2f(-ax, az) * RAD_TO_DEG;\n}\n\nvoid GestureAirDrawPro::startRecording(){\n  _count = 0;\n  _recording = true;\n  _hasResult = false;\n  _resultLabel[0]=0;\n}\n\nvoid GestureAirDrawPro::stopRecording(){\n  _recording = false;\n  if(_count < 6){ _hasResult = false; return; }\n  // make a copy and normalize\n  Point temp[MAX_SAMPLES];\n  for(int i=0;i<_count;i++) temp[i]=_buf[i];\n  normalizeToUnit(temp,_count);\n  // resample\n  Point sample[TEMPLATE_POINTS];\n  resample(temp,_count,sample,TEMPLATE_POINTS);\n  // compare with templates (generate on the fly)\n  float best = 1e9; int bestId = -1;\n  for(int id=0; id<NUM_TEMPLATES; id++){\n    Point templ[TEMPLATE_POINTS];\n    fillTemplate(templ, TEMPLATE_POINTS, id);\n    // templ currently in -1..1, map to 0..1000 like normalized sample\n    for(int i=0;i<TEMPLATE_POINTS;i++){\n      templ[i].x = (templ[i].x + 1.0f) * 500.0f;\n      templ[i].y = (templ[i].y + 1.0f) * 500.0f;\n    }\n    float d = dtwDistance(sample, TEMPLATE_POINTS, templ, TEMPLATE_POINTS);\n    if(d < best){ best = d; bestId = id; }\n  }\n  if(bestId >= 0 && best < 60.0f){ // threshold tuned empirically\n    if(bestId < 26){ _resultLabel[0] = 'A' + bestId; _resultLabel[1]=0; }\n    else { int digit = bestId - 26; _resultLabel[0] = '0' + digit; _resultLabel[1]=0; }\n    _hasResult = true;\n  } else {\n    _hasResult = false;\n  }\n}\n\nbool GestureAirDrawPro::availableResult() const { return _hasResult; }\nconst char* GestureAirDrawPro::getResultLabel() const { return _resultLabel; }\n\nvoid GestureAirDrawPro::printSVG(Print &out) const {\n  out.print(\"<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 1000 1000'>\\n\");\n  out.print(\"<polyline fill='none' stroke='black' stroke-width='4' points='\");\n  for(int i=0;i<_count;i++){\n    char buf[64];\n    snprintf(buf,sizeof(buf), \"%0.1f,%0.1f\", _buf[i].x, _buf[i].y);\n    out.print(buf);\n    if(i+1 < _count) out.print(' ');\n  }\n  out.print(\"'/>\");\n  out.print(\"\\n</svg>\\n\");\n}\n\nvoid GestureAirDrawPro::setSampleMs(unsigned long ms){ if(ms>=5) _sampleMs = ms; }\nvoid GestureAirDrawPro::setAlpha(float a){ if(a>0.0f && a<1.0f) _alpha = a; }\n\nvoid GestureAirDrawPro::normalizeToUnit(Point *arr, int n){\n  float xmin=1e9, xmax=-1e9, ymin=1e9, ymax=-1e9;\n  for(int i=0;i<n;i++){\n    if(arr[i].x < xmin) xmin = arr[i].x; if(arr[i].x > xmax) xmax = arr[i].x;\n    if(arr[i].y < ymin) ymin = arr[i].y; if(arr[i].y > ymax) ymax = arr[i].y;\n  }\n  float cx = (xmin + xmax) / 2.0f;\n  float cy = (ymin + ymax) / 2.0f;\n  float sx = (xmax - xmin) / 2.0f; if(sx < 1e-3f) sx = 1.0f;\n  float sy = (ymax - ymin) / 2.0f; if(sy < 1e-3f) sy = 1.0f;\n  float s = sx > sy ? sx : sy;\n  for(int i=0;i<n;i++){\n    float nx = (arr[i].x - cx) / s;\n    float ny = (arr[i].y - cy) / s;\n    arr[i].x = (nx + 1.0f) * 500.0f;\n    arr[i].y = (ny + 1.0f) * 500.0f;\n  }\n}\n\nvoid GestureAirDrawPro::resample(const Point *src, int nsrc, Point *dst, int ndst){\n  if(nsrc <= 1){ for(int i=0;i<ndst;i++){ dst[i] = src[0]; } return; }\n  for(int i=0;i<ndst;i++){\n    float t = (float)i / (ndst - 1);\n    float pos = t * (nsrc - 1);\n    int i0 = floor(pos);\n    int i1 = i0 + 1; if(i1 >= nsrc) i1 = nsrc - 1;\n    float f = pos - i0;\n    dst[i].x = src[i0].x * (1.0f - f) + src[i1].x * f;\n    dst[i].y = src[i0].y * (1.0f - f) + src[i1].y * f;\n  }\n}\n\nfloat GestureAirDrawPro::dtwDistance(const Point *a, int na, const Point *b, int nb){\n  const float INF = 1e9f;\n  static float D[TEMPLATE_POINTS+1][TEMPLATE_POINTS+1];\n  int N = na, M = nb;\n  for(int i=0;i<=N;i++) for(int j=0;j<=M;j++) D[i][j] = INF;\n  D[0][0] = 0.0f;\n  for(int i=1;i<=N;i++){\n    for(int j=1;j<=M;j++){\n      float dx = a[i-1].x - b[j-1].x;\n      float dy = a[i-1].y - b[j-1].y;\n      float cost = sqrtf(dx*dx + dy*dy);\n      float m = D[i-1][j];\n      if(D[i][j-1] < m) m = D[i][j-1];\n      if(D[i-1][j-1] < m) m = D[i-1][j-1];\n      D[i][j] = cost + m;\n    }\n  }\n  return D[N][M] / (N + M);\n}\n\nvoid GestureAirDrawPro::fillTemplate(Point *out, int n, int id){\n  for(int i=0;i<n;i++){ out[i].x = 0; out[i].y = 0; }\n  if(id < 26){\n    char ch = 'A' + id;\n    for(int i=0;i<n;i++){\n      float t = (float)i / (n - 1);\n      switch(ch){\n        case 'A': out[i].x = -1.0f + 2.0f*t; out[i].y = 1.0f - fabs(out[i].x) * 1.8f; break;\n        case 'B': out[i].x = -0.6f + 1.2f * sinf(t * 3.14159f * 2.0f); out[i].y = cosf(t * 3.14159f * 2.0f); break;\n        case 'C': { float a = -1.2f + 2.4f * t; out[i].x = cosf(a); out[i].y = sinf(a); } break;\n        case 'D': { float a = -1.0f + 2.0f * t; out[i].x = cosf(a*1.2f); out[i].y = sinf(a*1.2f); } break;\n        case 'E': if(t < 0.5f){ out[i].x = -1.0f; out[i].y = -1.0f + 4.0f * t; } else { out[i].x = -1.0f + 2.0f * (t-0.5f); out[i].y = 1.0f; } break;\n        default: out[i].x = cosf(t * 2.0f * 3.14159f + id); out[i].y = sinf(t * 2.0f * 3.14159f + id*0.5f); break;\n      }\n    }\n  } else {\n    int d = id - 26;\n    for(int i=0;i<n;i++){\n      float t = (float)i / (n - 1);\n      switch(d){\n        case 0: { float a = t * 2.0f * 3.14159f; out[i].x = cosf(a); out[i].y = sinf(a); } break;\n        case 1: out[i].x = 0.0f; out[i].y = -1.0f + 2.0f * t; break;\n        case 2: out[i].x = -1.0f + 2.0f * t; out[i].y = sinf(t * 3.14159f); break;\n        case 3: out[i].x = sinf(t * 6.28318f); out[i].y = sinf(t * 6.28318f) * 0.8f; break;\n        case 4: if(t<0.6f){ out[i].x = -0.6f; out[i].y = -1.0f + (t/0.6f)*2.0f; } else { out[i].x = -0.6f + (t-0.6f)/0.4f*1.2f; out[i].y = 0.2f; } break;\n        case 5: out[i].x = -1.0f + 2.0f * t; out[i].y = sinf((t-0.25f) * 3.14159f * 1.5f); break;\n        case 6: out[i].x = cosf(t * 6.28318f) * 0.6f - 0.2f; out[i].y = sinf(t * 6.28318f) * 0.8f; break;\n        case 7: out[i].x = -1.0f + 2.0f * t; out[i].y = -1.0f + (t<0.5f?2.0f*t:1.0f); break;\n        case 8: out[i].x = cosf(t * 6.28318f) * 0.5f; out[i].y = sinf(t * 6.28318f) * 0.8f; break;\n        case 9: out[i].x = cosf(t * 6.28318f) * 0.5f + 0.3f; out[i].y = sinf(t * 6.28318f) * 0.6f; break;\n        default: out[i].x = cosf(t*6.28318f); out[i].y = sinf(t*6.28318f); break;\n      }\n    }\n  }\n}\n\n// low-level MPU6050 read\nvoid GestureAirDrawPro::readRawAccelGyro(float &ax,float &ay,float &az,float &gx,float &gy,float &gz){\n  _wire->beginTransmission(_addr);\n  _wire->write(0x3B);\n  _wire->endTransmission(false);\n  _wire->requestFrom((int)_addr, 14);\n  if(_wire->available() < 14){ ax=ay=az=gx=gy=gz=0; return; }\n  int16_t rawAx = (_wire->read()<<8) | _wire->read();\n  int16_t rawAy = (_wire->read()<<8) | _wire->read();\n  int16_t rawAz = (_wire->read()<<8) | _wire->read();\n  _wire->read(); _wire->read();\n  int16_t rawGx = (_wire->read()<<8) | _wire->read();\n  int16_t rawGy = (_wire->read()<<8) | _wire->read();\n  int16_t rawGz = (_wire->read()<<8) | _wire->read();\n  ax = rawAx / 16384.0f; ay = rawAy / 16384.0f; az = rawAz / 16384.0f;\n  gx = rawGx / 131.0f; gy = rawGy / 131.0f; gz = rawGz / 131.0f;\n}\n\nvoid GestureAirDrawPro::mapOrientationToXY(float &x,float &y){\n  float dp = _pitch;\n  float dr = _roll;\n  x = 500.0f + dr * 6.5f;\n  y = 500.0f - dp * 6.5f;\n  if(x<0) x=0; if(x>1000) x=1000;\n  if(y<0) y=0; if(y>1000) y=1000;\n}\n\nvoid GestureAirDrawPro::update(){\n  unsigned long now = millis();\n  if(now - _lastMs < _sampleMs) return;\n  float dt = (now - _lastMs) / 1000.0f;\n  _lastMs = now;\n  static int prevBtn = HIGH;\n  int btn = digitalRead(_buttonPin);\n  if(btn == LOW && prevBtn == HIGH){ if(!_recording) startRecording(); else stopRecording(); }\n  prevBtn = btn;\n  float ax,ay,az,gx,gy,gz;\n  readRawAccelGyro(ax,ay,az,gx,gy,gz);\n  float accelPitch = atan2f(ay, sqrtf(ax*ax + az*az)) * RAD_TO_DEG;\n  float accelRoll  = atan2f(-ax, az) * RAD_TO_DEG;\n  _pitch += gx * dt; _roll  += gy * dt;\n  _pitch = _alpha * _pitch + (1.0f - _alpha) * accelPitch;\n  _roll  = _alpha * _roll  + (1.0f - _alpha) * accelRoll;\n  float x,y; mapOrientationToXY(x,y);\n  if(_recording && _count < MAX_SAMPLES){ _buf[_count].x = x; _buf[_count].y = y; _count++; }\n}\n